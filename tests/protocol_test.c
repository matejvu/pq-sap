#include "protocol_api.h"
#include "stdio.h"

/**
 * @brief Main function that runs the SAP Protocol test.
 *
 * This function simulates the key exchange and stealth address generation
 * process within the SAP protocol. It includes key pair generation,
 * computation of the shared secret and view tag by the sender,
 * and stealth address generation by both the sender and recipient.
 * The test is passed if the stealth addresses generated by the sender
 * and recipient match.
 *
 * @return 0 if the test passes, indicating successful execution;
 *         otherwise, returns early on failure.
 */

int main() {

    /// Local variables:
    uint8_t k_pub[KYBER_PUBLICKEYBYTES];  /// -  k_pub[#KYBER_PUBLICKEYBYTES]: Public key for key exchange
    uint8_t v_pub[KYBER_PUBLICKEYBYTES];  /// - v_pub[#KYBER_PUBLICKEYBYTES]: Public key for the view address
    uint8_t k_priv[KYBER_SECRETKEYBYTES]; /// - k_priv[#KYBER_SECRETKEYBYTES]: Secret key for key exchange
    uint8_t v_priv[KYBER_SECRETKEYBYTES]; /// - v_priv[#KYBER_SECRETKEYBYTES]: Secret key for the view address

    uint8_t ephemeral_pub_key[CIPHERTEXT_BYTES]; /// - ephemeral_pub_key[#CIPHERTEXT_BYTES]: Ephemeral public key used in the protocol
    uint8_t view_tag; /// - view_tag: View tag computed by the sender, used for generating the stealth address
    uint8_t stealth_pub_key_sender[STEALTH_ADDRESS_BYTES]; /// - stealth_pub_key_sender[#STEALTH_ADDRESS_BYTES]: Stealth public key generated by the sender
    uint8_t stealth_pub_key_reciever[STEALTH_ADDRESS_BYTES]; /// - stealth_pub_key_reciever[#STEALTH_ADDRESS_BYTES]: Stealth public key generated by the recipient
    uint8_t ss[KYBER_SSBYTES]; /// - ss[#KYBER_SSBYTES]: Shared secret from the sender's computation (sender's shared secret)
    uint8_t ss2[KYBER_SSBYTES]; /// - ss2[#KYBER_SSBYTES]: Shared secret from the recipient's computation (recipient's shared secret)



    printf("SAP Protocol: ");

    /// SAP Protocol: 
    /// 1. Generate key pair for both the sender and recipient. The sender generates a public/private key pair calling crypto_kem_keypair(k_pub, k_priv), and the recipient generates their own keys calling crypto_kem_keypair(v_pub, v_priv)
    crypto_kem_keypair(k_pub, k_priv);
    crypto_kem_keypair(v_pub, v_priv);

    printf("KYBER_K: %d\n", KYBER_K);

    // crypto_kem_enc(ephemeral_pub_key, ss, v_pub);
    // crypto_kem_dec(ss2, ephemeral_pub_key, v_priv);

    // for(int i=0; i< KYBER_SSBYTES; i++){
    //     printf("%d", ss[i]);
    // }printf("\n\n");

    // for(int i=0; i< KYBER_SSBYTES; i++){
    //     printf("%d", ss2[i]);
    // }
   



    /// 2. Sender computes the shared secret and view tag using the public keys( sender_computes_stealth_pub_key_and_viewtag() ) 
    sender_computes_stealth_pub_key_and_viewtag(stealth_pub_key_sender, ephemeral_pub_key,
        &view_tag, v_pub, k_pub);
    
    
    /// 3. Recipient computes the stealth public key based on the sender's ephemeral public key. The recipient calculates their own stealth address based on their private key, the sender's public key, and the sender's ephemeral public key. Calling recipient_computes_stealth_pub_key()
    recipient_computes_stealth_pub_key(stealth_pub_key_reciever,
        k_pub,
        ephemeral_pub_key,
        v_priv);
    

    /// 4. Verify that the stealth public keys generated by the sender and recipient match. The final step of the protocol is to compare the stealth public key computed by the sender and recipient. If they match, the test passes, indicating that the protocol works correctly. Test fails if the computed stealth public keys do not match

    for (int i = 0; i < STEALTH_ADDRESS_BYTES; i++) {
        if (stealth_pub_key_reciever[i] != stealth_pub_key_sender[i]) {

            // printf("R: %d\tS: %d\n", stealth_pub_key_reciever[i], stealth_pub_key_sender[i]);
            printf("Test FAILED!\n");
            return 0;
        }
    }
    printf("Test PASSED!\n");
}


// let (k_pub, _) = key_pair(); 
// let (v_pub, v_priv) = key_pair(); 


// let (stealth_pub_key_sender, ephemeral_pub_key, _) = sender_computes_stealth_pub_key_and_viewtag(&v_pub, &k_pub);

// let stealh_pub_key_recipient = recipient_computes_stealth_pub_key(&k_pub, &ephemeral_pub_key, &v_priv);  

// assert_eq!(stealh_pub_key_recipient, stealth_pub_key_sender); ajde mi ovde dodaj te komentare u nitaciji doxyfile-a